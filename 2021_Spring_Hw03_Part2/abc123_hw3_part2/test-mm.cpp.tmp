#include <iostream>
#include <mutex>
#include <thread>

#define NUMTHREADS 4

using namespace std;

typedef struct MatThrArgs {
    int id;
    int numThreads;
    double *A;
	double *B;
	double *C;
	int N;
    int i_start;
    int step;
	int i_stop;
} MatThrArgs_t;

void printMat (double *A, int N, const char* label) {
    cout << label << endl;
    for (int i=0; i<N; i++) {
        for (int j=0; j<N; j++) {
            cout << A[i*N + j] << ", ";
        }
        cout << endl;
    }
    cout << endl;
}

void transpose (double *A, int N)
{
    double t;
    for (int i = 0; i < N; i++) {
        for (int j = i+1; j < N; j++) {
            t = A[i*N + j];
            A[i*N + j] = A[j*N + i];
            A[j*N + i] = t;
        }
    }
}

void matrix_multi(struct MatThrArgs *params) {

    for(int i = params->i_start; i < params->i_stop; i++)
    {
        for(int j = 0; j < params->N; j++)
        {
            double tmp = 0;
            for(int l=0; l < params->N; l++)
            {
                tmp += (params->A)[params->N*i+l] * (params->B)[params->N*j+l];
            }
            cout << "Thread: " << params->id << " , Computing C[" << i << "][" << j << "]" << endl;
            (params->C)[params->N*i + j] = tmp;
        }
    }
}

void thrTxpose(struct MatThrArgs *params)
{
    int N = params->N;
    double t;
    double *A = params->A;
    
    for(int i = params->i_start; i < params->i_stop; i += params->step)
    {
        cout << "Thread : " << params->id << " , i = " << i << endl;
        for(int j = i+1; j < N; j++)
        {
            t = A[i*N + j];
            A[i*N + j] = A[j*N + i];
            A[j*N + i] = t;
        }   
    }
}

void transposeThreaded(double *A, int N) {

    struct MatThrArgs *params = new struct MatThrArgs[NUMTHREADS];

    for (int i = 0; i < NUMTHREADS; i++)
	{
		params[i].i_start = i;
		params[i].i_stop = N;
		params[i].id = i;
        params[i].A = A;
		params[i].N = N;
        params[i].step = NUMTHREADS;
	}

    thread t[NUMTHREADS];

    cout << "[Txpose Threaded] Firing threads ->" << endl;

    for (int i = 0; i < NUMTHREADS; i++) {
		t[i] = thread(thrTxpose, &params[i]);
	}

    for (int i = 0; i < NUMTHREADS; i++) {
    	t[i].join();
    }

    cout << "[Txpose Threaded] Threads joined ->" << endl;

    delete [] params;
}

// transpose based MMA
void matrix_mult_opt_threaded(double *A, double *B, double *C, int N)
{
    int row, col, i, j, k;
	double sum;

    transposeThreaded(B, N);
    printMat(B, N, "Txpose(B):");

    // matrix_multi(params);

    struct MatThrArgs *params = new struct MatThrArgs[NUMTHREADS];

    for (int i = 0; i < NUMTHREADS; i++)
	{
		params[i].i_start = i * (N/NUMTHREADS);
		params[i].i_stop = (i + 1) * (N/NUMTHREADS);
		params[i].id = i;
        params[i].A = A;
		params[i].B = B;
		params[i].C = C;
		params[i].N = N;
	}

    thread t[NUMTHREADS];

    cout << "Firing threads ->" << endl;

    for (int i = 0; i < NUMTHREADS; i++)
	{
		t[i] = thread(matrix_multi, &params[i]);
	}

    for (int i = 0; i<NUMTHREADS; i++) {
    	t[i].join();
    }

    cout << "Threads joined." << endl;    

    delete [] params;
}

void matrix_mult_opt(double *A, double *B, double *C, int N) {

		printMat(B, N, "Mat B:");
		transpose(B, N);
		printMat(B, N, "Txpose(B):");

		for(int i = 0; i <N; i++)
		{
			for(int j = 0; j < N; j++)
			{
				double tmp = 0;
				for(int l=0; l < N; l++) {
					tmp += A[N*i+l] * B[N*j+l];
				}
				C[N*i + j] = tmp;
			}
		}
}

void naive_worker(MatThrArgs_t *params) {
	double *A = params->A, *B = params->B, *C = params->C;
	int N = params->N;

	for (int i = params->i_start; i < params->i_stop; i++) {
		for (int j = 0; j < N; j++) {
			C[i*N + j] = 0.0;
			for (int k = 0; k < N; k++) {
				C[i*N + j] += A[i*N + k] * B[k*N + j]; 
			}
		}
	}
}

// naive threaded MMA
void matrix_mult_naive_threaded(double *A, double *B, double *C, int N) {
	int row, col, i, j, k;
	double sum;

    struct MatThrArgs *params = new struct MatThrArgs[NUMTHREADS];

    for (int i = 0; i < NUMTHREADS; i++)
	{
		params[i].i_start = i * (N/NUMTHREADS);
		params[i].i_stop = (i + 1) * (N/NUMTHREADS);
		params[i].id = i;
        params[i].A = A;
		params[i].B = B;
		params[i].C = C;
		params[i].N = N;
	}

    thread t[NUMTHREADS];

    cout << "Firing threads ->" << endl;

    for (int i = 0; i < NUMTHREADS; i++)
	{
		t[i] = thread(naive_worker, &params[i]);
	}

    for (int i = 0; i<NUMTHREADS; i++) {
    	t[i].join();
    }

    cout << "Threads joined." << endl;    

    delete [] params;
}

void matrix_mult_naive(double *A, double *B, double *C, int N)
{
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
		{
			C[i * N + j] = 0;
			for (int k = 0; k < N; k++)
			{
				C[i * N + j] += A[i * N + k] * B[k * N + j];
			}
		}
}

int main () {

    int N = 16;
    double *A = new double[N*N];
    double *B = new double[N*N];
    double *C = new double[N*N];

    for (int i=0; i<N; i++) {
        for (int j=0; j<N; j++) {
            A[i*N + j] = i;
            B[i*N + j] = 0;
        }
        B[i*N + i] = 2.0;
    }

    B[1] = 1;

    printMat(A, N, "A");
    printMat(B, N, "B");

    matrix_mult_opt_threaded(A, B, C, N);

    printMat(C, N, "C");

    transpose(B, N);

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            C[i*N + j] = 0;
        }
    }
    
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            for (int k = 0; k < N; k++) {
                C[i*N + j] += A[i*N + k] * B[k*N + j] ;
            }
        }
    }

    printMat(C, N, "serial comp. C:");

    free(A); free(B); free(C);

    return 0;
}
